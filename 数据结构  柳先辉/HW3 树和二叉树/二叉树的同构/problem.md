# 二叉树的同构
描述
给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点a、b、e的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。

![image](https://github.com/user-attachments/assets/08b91f32-9e4b-439e-a9ff-006a00fd02aa)

图1

![image](https://github.com/user-attachments/assets/afeb1c99-e079-4acb-9761-c00535cac052)

图2

现给定两棵树，请你判断它们是否是同构的。并计算每棵树的深度。

输入:
第一行是一个非负整数N1，表示第1棵树的结点数；

随后N行，依次对应二叉树的N个结点（假设结点从0到N−1编号），每行有三项，分别是1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。

接着一行是一个非负整数N2，表示第2棵树的结点数；

随后N行同上描述一样，依次对应二叉树的N个结点。

对于20%的数据，有0<N1=N2<=10

对于40%的数据，有0<=N1=N2<=100

对于100%的数据，有0<=N1,N2<=10100

注意：题目不保证每个结点中存储的字母是不同的。

下载p81_data.cpp并编译运行以生成随机测试数据

输出:
共三行。

第一行，如果两棵树是同构的，输出“Yes”，否则输出“No”。

后面两行分别是两棵树的深度。

 

输入样例（对应图1）：
6
A 1 4
B 2 3
C - -
D - -
E 5 -
F - -
6
B 4 3
F - -
A 5 0
C - -
D - -
E 1 -
 
输出样例1:
Yes
3
3
 
输入样例2（对应图2）：
6
A 1 4
B 2 3
C - -
D - -
E 5 -
F - -
6
B 1 -
F - -
A 0 5
C - -
D - -
E 4 3
输出样例2:
No
3
3

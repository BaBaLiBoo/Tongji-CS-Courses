# 算法类题组-1-文件压缩
时间限制	1000ms	空间限制	512MB

（建议配合毛不易歌曲《给你给我》阅读下面的导言故事）

关于爱乐普第研究所还有个故事，只不过很少有人知道

那还是小甜十八岁出头的年纪，那时候他刚刚踏入学校，那时候出门还不用戴口罩，进校园里也没有那么多的拘束，四平大草坪前面的路，还有散步的老头老太太，推着婴儿车的年轻妈妈，偶尔穿过人群的外卖小哥、和三三两两去上课、去吃饭的学生们。

小甜就是在这里遇见她的，在那个夏天的尾巴。

起因是小甜的朋友，说他的妹妹有一些数据需要压缩，问小甜可不可以帮忙，小甜本来以为没什么，但是听到对方说要将一个移动硬盘交给他的时候，他还是心里震惊了一下，震惊到对她的第一印象，没有夏风吹过的大草坪，只有那 40G 的数据。

再次见到她的时候，是在图书馆，那时候小甜正在埋头写文件压缩，刚写好，一抬头，就看到了一双清澈的眼睛。

是她和她哥哥，也就是小甜的朋友。他说，老远就看到你在这里，一起去吃饭吗，小甜点了点头，开始收拾东西。路上他们一起说了压缩的进展，小甜给她讲 Huffman 和 LZ 的区别，路的中央有猫在晒太阳。

于是他们就这样熟了起来，日子像水一样流淌，这之中具体发生了什么，小甜自己也记不清，只记得早八的课桌上有时候会有一杯豆浆，下课的时候有时候会去北楼门口等她下课，晚上散步的时候、遇见南北楼外的空地开灯，那一瞬间，好像身边的人也发起光来。

不久以后就到了期末。这是他们在上海度过的第一个冬天，冬天好冷，下了晚课他们一起去买门口冒着热气的烤红薯，她说，你还记得刚开学那会帮我做的压缩文件吗、那个压缩率可以再高一点吗，在烤红薯氤氲的热气里，小甜点了点头。

但是匆忙的期末周怎么会给你很多空余的时间，时间一转，已经是他们在车站分别了。他们拥抱，小甜看着她检票进站、她说、交给你的任务要好好完成，小甜说，绝不偷懒。

回到家的日子好像也没什么变化，他们会在微信上分享最近的生活，电视里放着关于不明原因肺炎的新闻、小甜闲的时候就去研究算法。

直到有一天，她说，我好像发烧了、要被送去隔离了。

然后就再没有消息。

过年、初春、河水解冻、樱花在校园里独自地开，时针在太阳在东升西落里转了一圈又一圈。

都没有消息。

直到返校的时候，小甜站在全副武装的学校大门面前，觉得什么都没变、又好像什么都变了。

究竟是什么变了呢，桂花依旧在风里泛着香，九月的阳光和去年一样晴朗。


小甜就是在那里遇见她的，在那个夏秋之交。

许多年后小甜和别人说起她的时候，说，就叫她阿秋吧。

至于那个文件，小甜也花了一点小心思。如果解压的时候，会看到最后多了一个文件，里面只有一句话：

我要把你写在我的余生里。

小甜在写的时候，甚至想到，她看到这里，脸红地笑一下的样子。

可惜没有回复了。

但是我被你写在了生命里。


直到在爱乐普第研究所的日子，已经是很多年以后了。一天，陈博士问大家，有什么新的作业值得发布，小甜想了一下，说，那就文件压缩吧


那段故事、那些没有疫情的日子，都被压缩在了那个秋天里。
## 文件压缩
### 1. 背景
文件的压缩和解压缩可以被视为一种数据转换过程，其中压缩算法将原始数据转换成一种更紧凑的表示形式，而解压缩算法则将这种紧凑的表示形式恢复成原始数据。文件压缩的方法有很多，他们可以分为有损压缩 / 无损压缩两种。

无损压缩是一种确保数据在压缩和解压缩后能够完全恢复的技术。无损压缩方法通过优化数据存储方式来减少文件大小，适用于需要精确数据恢复的场景，如文档和代码和某些类型的图像。常见的无损压缩算法包括霍夫曼编码、LZ4以及DEFLATE等；常见的 zip, rar 等格式的压缩文件均为无损压缩。

有损压缩则是一种在减少数据大小的同时允许一定程度信息损失的技术。由于人的视觉和听觉系统对某些细节的敏感度有限，因此有损压缩方法特别适用于多媒体数据，如图像、音频和视频。常见的有损压缩算法包括JPEG、MP3和H.264等；大部分的图片 (如 jpg, png, gif)、视频 (如 mp4, m4v) 或者音频 (如 mp3) 都是有损压缩的格式。

我们将会给出一份服务器日志记录，你只需要观察这份日志文件的规律，自行设计一种简单的压缩 / 解压缩算法即可。当然，我们也欢迎你尝试复现已有的压缩 / 解压缩算法。

### 2. 要求
本次作业要求你自己设计或参考现有的压缩与解压缩方法，编写一个程序，支持文件的压缩与解压缩操作。换句话说，你需要：
```
① 实现压缩功能，将源文件（下面会给出）转换成你设计的某种压缩格式

② 实现解压缩方法，将符合你约定格式的压缩文件解压回原本的格式
```
日志文件点此下载 ，你会得到一个压缩包，其中的 .log 文件即为日志文件。

具体要求如下：

⚠ 压缩比应该在 
80
%
 以下 (即压缩后文件的大小应当小于未压缩文件的 
80
%
 ) ⚠
 
⚠ 程序需要使用 cmdline 方式读取参数，参数格式为 {压缩文件名} {输出文件名} {压缩指令} ⚠

压缩文件名和输出文件名由用户指定，压缩指令只能是 zip 或 unzip 。换句话说，每次运行程序时，用户可以在 cmd 窗口通过传参的方式指定本次执行的是压缩还是解压缩操作。
```
// 再次提醒，参数不是程序运行之后等待用户输入的，而是在cmd窗口执行exe时传入的
// 压缩例如下，其代表将src.xxx压缩，结果保存在dst.xxx
//   [你的程序路径] src.xxx dst.xxx zip 
// 解压缩例如下，其代表将src.xxx解压缩，结果保存在dst.xxx
//   [你的程序路径] src.xxx dst.xxx unzip 

// 注：文件名中后缀（如.txt）的作用是告诉操作系统应该以什么方法读取文件的内容，因此修改后缀并不会改变文件中的内容
```
3.⚠ 对于我们给的日志文件，程序需要在 
15
 秒内完成压缩 / 解压缩操作 ⚠

4.请使用 std::fstream 文件流方式操作文件

5.请自行完成压缩 / 解压缩底层操作，不要使用外部库函数

6.如果你设计 / 参考的压缩方法是有损压缩，请保证重要信息有所保留
```
// 我们已经对文件中的IP进行匿名化(即你所看到的IP均已被修改为 ***.***.***.***)，但是IP理论上应为日志的重要信息，所以如果你采用的是有损压缩的话，请你对于所有匿名的IP予以保留。
// 另外，如果你设计/参考的压缩方法是无损压缩，你可以使用fc指令比较原本的文件和经过一套压缩-解压缩还原的文件是否相同，来验证你的算法的准确性
```

### 3. 高分提示
如果你希望你的程序能够获得高分，你可以考虑在以下几个方向进行探索。

1.更优的压缩比： 压缩之后的文件更小

2.更短的程序执行时间： 压缩 / 解压缩速度更快

3.更精巧的核心算法： 压缩的设计算法有更强的理论支撑，或形式简洁/思路巧妙

4.更通用的算法/程序： 对于其他内容或其他格式的文件，算法也能达到要求
### 4. 示例程序
下面是一段实现有损压缩方法的程序，其压缩算法的核心思路十分简单：直接删掉一些设计者认为不那么重要的信息。
```
#include <fstream>
#include <iostream>
#include <string>
using namespace std;

void replaceString(string &origin, string old_value, string new_value) {
  /* 该函数用于对 origin 全文查找出现的 old_value 并用 new_value 替换 */
  for (string::size_type pos(0); pos != string::npos;
       pos += new_value.length()) {
    if ((pos = origin.find(old_value, pos)) != string::npos) {
      origin.replace(pos, old_value.length(), new_value);
    } else {
      break;
    }
  }
}

int main(int argc, char *argv[]) {
  cout << "Zipper 0.001! Author: root" << endl;
  if (argc != 4) {
    cerr << "Please make sure the number of parameters is correct." << endl;
    return -1;
  }

  if (strcmp(argv[3], "zip")) {
    cerr << "Unknown parameter!\nCommand list:\nzip" << endl;
    return -1;
  }

  ifstream fin(argv[1], ios::binary); // 以二进制方式打开文件
  if (!fin) {
    cerr << "Can not open the input file!" << endl; // 输出错误信息并退出
    return -1;
  }

  istreambuf_iterator<char> beg(fin),
      end; // 设置两个文件指针，指向开始和结束，以 char(一字节) 为步长
  string content(beg, end); // 将文件全部读入 string 字符串
  fin.close(); // 操作完文件后关闭文件句柄是一个好习惯

  /* 在这里对冗余数据进行剔除 */
  replaceString(content,
                "#Software: Hllpoj Server 1.0.1 / Logger 1.0.0 built "
                "0001\r\n#Version: 1.0\r\n#Date: 2019-03-13 ",
                "");
  replaceString(
      content,
      "#Fields: date time s-ip cs-method cs-uri-stem cs-uri-query s-port "
      "cs-username c-ip cs(User-Agent) cs(Referer) sc-status sc-substatus "
      "sc-win32-status time-taken",
      "");
  replaceString(content,
                "Mozilla/5.0+(Windows+NT+10.0;+Win64;+x64)+AppleWebKit/"
                "537.36+(KHTML,+like+Gecko)+",
                "");
  replaceString(content, "2019-03-13 ", "");

  ofstream fout(argv[2], ios::binary); // 打开输出文件
  if (!fout) {
    cerr << "Can not open the output file!" << endl;
    return -1;
  }
  fout << content; // 直接将操作好的字符串进行输出
  fout.close();

  cout << "Complete!" << endl;
  return 0;
}
```
注意！该示例程序压缩率 
83.15
%
 尚未达标，所以如果你想基于样例程序完成你的作业，你应该重点考虑怎么优化程序 (如优化 replaceString() 的性能表现，或是读入文件的性能表现)；当然，我们建议你尽量尝试使用无损压缩方法完成本次作业。


## 附录 - 带参主函数
我们都知道，在编写 C/C++ 程序时，主函数 main() 是特别重要的，因为如果缺少这个函数的实现，我们的程序就无法编译。就像C/C++ 中的所有其他函数一样，主函数 main() 函数也能够接受参数。向主函数 main() 传递参数与向其他函数传递参数的区别在于，在前一种情况下，我们必须通过命令行传递参数，因为主函数 main() 本身是驱动函数，所以没有其他函数能够调用它并向它传递参数。

argv 和 argc 是 C 和 C++ 中向 main() 传递命令行参数的方式。按照惯例，这两个变量被命名为 argc（argument count, 参数计数）和 argv（argument vector, 参数向量），但它们可以被赋予任何有效的标识符——例如 int main(int num_args, char** arg_strings) 也是有效的。argc 是 argv 所指向的字符串的数量，在程序中一般表示 1 加上参数的数量。

如果你不打算处理命令行参数，也可以完全省略它们，就像我们所习惯的那样，写成 int main() 的形式。

考虑下面的 C++ 程序：
```
// filename: test.cpp
#include <iostream>

int main(int argc, char** argv) {
  std::cout << "This program has " << argc << " arguments:" << std::endl;
  for (int i = 0; i < argc; ++i) {
    std::cout << argv[i] << std::endl;
  }
  return 0;
}
```
在命令行输入命令 g++ ./test.cpp -o test 编译程序，并以命令 ./test hello world alpd 运行程序，会得到以下输出：
```
This program has 4 arguments:
test
hello
world
alpd
```
